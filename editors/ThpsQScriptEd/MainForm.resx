<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="menuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <data name="wordWrapToolStripMenuItem.ToolTipText" xml:space="preserve">
    <value>Warning: the text editor is based on default WinForms TextBox,
which is known to cause a massive lag when resizing with a huge
amount of text inside. Also, you might want to have this disabled,
since qScript interprets new line as an ending symbol, much like
semicolon (;) in other languages.</value>
  </data>
  <metadata name="statusStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>132, 21</value>
  </metadata>
  <data name="codeBox.Text" xml:space="preserve">
    <value>QScripted
2018, DCxDemo*.

QScripted is meant to be a fast, lightweight and reliable qScript editor (includes both compiler and decompiler).

qScript is a loose name for the scripting language developed by Neversoft
for Tony Hawk's Pro Skater series, also used in some other titles.
Script files used .q extension, while compiled scripts used .qb extension.

Main goal for this project is to fully support the original qScript syntax, as well
as addition of some minor tweaks to enhance the experience.
Some original scripts can be found on the japanese THPS 2003 CD with a .BAK extension.

Keep in mind the target syntax is THPS3, specifically for LevelMod development.
While it may and certainly will work for selected files from later games, it is not
guaranteed and expected to crash in some way (unimplemented opcodes, missing keywords, etc).

!===================Disclaimer====================!
!                                                 !
! Warning! This tool is not production ready      !
! Do not edit important files without a backup.   !
!                                                 !
! There is a handy option that backups every time !
! you hit F5 as well as a rollback feature.       !
!                                                 !
!=================================================!



### Known bugs and unsupported stuff ###

- random inside another random aka random(@random(@x @y) @z)
- newer thug+ random
- thug2+ ifs with offset
- thug2+ endswitch?

### Bug reports ###

report bugs if found any, but please make sure it's the actual tool bug
and not a missing closing bracket. provide a minimum viable script to
reproduce the problem in your report.

### Script editing ###

For a better coding experience I advice you to install NotePad++, apply qScript 
syntax highlighting and assign it as an external editor in settings.
Integration suggestions are welcome.

And don't enable word wrap, it lags. It's a compiler after all, not an IDE.



Some sort of manual:

### Tricks and tips ###

- This tool loads precompiled global symbol cache from disk. This allows to load
stripped scripts as well as lookup correct string by its hash.
- There is a simple bracket counter that will warn you in case you forgot to add
a paired one. helps to avoid silly bugs.
- every time you compile a script, there is an option to create a new backup.
this way you can easily rollback to a previous state of your source. it is recommended
to always store q source along with your compiled scripts, so you can keep comments there.
- degree notation support, 180° is treated as float 3.1415...
- due to how the lexer is written, it is recommended to use space symbol everywhere,
cause you rather stay safe than guess what works and what doesnt. for example, when 
defining a struct, just write "some_struct = {" instead of "some_struct={".
it's easier to read, but also helps compiler to avoid the confusion.


### Comments ###

commenting is supported

;this is a comment
//this is a comment too
/*
multi line comments
are not supported yet
*/

comments are only saved in q source and completely discarded in qb
keep in mind that if you don't check "remove trailing new lines,
qb file will contain an extra newline opcode for every comment line.


### Hash symbol ###

every string that was not recognized as a keyword or operator will be turned into a symbol
if a string contains space symbol, there is hash operator for those:
#"string to hash"

for words without spaces it doesn't matter whether you'll write it or not 

testword is equal to #"testword"


### Numeric types ###

1 is parsed as int
-2 is parsed as int
.5 is parsed as float
-1.5 is parsed as float too

90° is an angle in degrees. it is converted to float value in radians.
rad = deg / 180 * Pi.

by default all float values will decompile with at least 1 decimal zero, which means
1 is originally int and 1.0 is originally float


### Pairs and vectors ###

vectors are defined as 2 or 3 embraced comma separated numeric values:
(0, 0)
(640, 480)
(1.0, -1.0)
(255.0, 255.0, 255.0)
(45°, -90°, 180°)

keep in mind there is no vector4 and above.

(0, 0, 0, 0) will be converted as is: open bracket, num, comma, num, comma, etc.


### Escape sentences ###

these are supported: \' \" \\
new line is | in thps3.


### Passing arguments/parameters ###

you can pass a param using &lt;&gt;: SomeFunc myparam = &lt;someparam&gt;
to pass everything given, use &lt;...&gt;: SomeFunc &lt;...&gt; 
note that &lt;...&gt; is a keyword, you can't write &lt; . . . &gt;.
this is also referred to as "global" in thqbeditor.


### Operators ###

be careful, minus sign will only work with spaces.
i--5 - incorrect. will compile into symbol "i--5"
i - -5 - correct. will compile to symbol "i", opcode minus, int -5

other math operators work without spaces just fine
i+5 aka i + 5 aka i+ 5 aka i +5

and/or requires space as well.
x and y aka x &amp;&amp; y, but not x&amp;&amp;y
x or y aka x || y , but not x||y

not x aka !x , this one works without space


### Class property and methods ###

introduced in THPS4
Skater:GetPosition
Skater.Position

please note that due to these operators your symbols can't include : and .
this requires thorough testing since this is not supported in THPS3.


### Random ###

random code is executed using this syntax

dostuff somepram = random( @1 @2 @3 )

different randoms include random, randomnorepeat, randompermute, (someotherrandom)

! currently you can't use random inside another random, it won't compile correctly. !


### Randomrange ###

randomrange is a different type of random.
it simply generates a random float value within the range.

randomRange (0.5, 10.5)


### NodeArray specific stuff ###

Angle node param can be optionally visualized in degress.
The original vector value stores angles in radians. 
so basically, while the code will look like: Angles = (180°, 180°, 180°)
it will compile to: Angles = (3.1415, 3.1415, 3.1415)
see numeric types for radian math explanation.

!!! ATTENTION !!!

This tool replaces link indices in NodeArray with the actual node name.
for this to work correctly, every node must have a name, and the same
file should contain TriggerScripts array defined AFTER NodeArray.

This feature allows you to easily reorder nodes in the array as you don't
have to care about the correct indices anymore.

NodeArray = [
  { Position = (0,10,0) Name = Node01 Class = RailNode }
  { Position = (0,20,0) Name = Node02 Class = RailNode Links = [ Node01 ] }
  //will actually compile to Links = [ 0 ] cause Node01 index is 0 in this array
]



### Cheers to ###

vadru for being the thps3 modding guru for all these years.
inoX for writing THQBEditor (assisted by vadru).
TnT for bringing attention to THPS 2003 files.
someguy for py script
and everyone who ever worked on QB stuff</value>
  </data>
</root>